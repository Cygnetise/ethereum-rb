// Generated by CoffeeScript 1.10.0
(function() {
  var c, deployContract, displayErr, env, eth, fs, renderDeployError, saveContractAddress;

  fs = require('fs');

  env = require('./env');

  c = console;

  eth = env.eth;

  saveContractAddress = function(contract_name, instance_address) {
    var config, config_json, config_path, contracts_config, contracts_json_path;
    config_path = (process.cwd()) + "/../config";
    contracts_json_path = config_path + "/contracts.json";
    contracts_config = fs.readFileSync(contracts_json_path);
    config = JSON.parse(contracts_config);
    config[contract_name] = instance_address;
    config_json = JSON.stringify(config, null, 2);
    return fs.writeFileSync(contracts_json_path, config_json);
  };

  displayErr = function(label, err) {
    c.error("Got error when '" + label + "':");
    return c.error((JSON.stringify(err)) + "\n");
  };

  renderDeployError = function(res, err) {
    var message;
    displayErr("deploying contract", err);
    if (err.message === "Account does not exist or account balance too low") {
      c.log("Coinbase address: '" + coinbase + "'");
      eth.getBalance(coinbase, function(err, balance) {
        return c.log("Balance: " + balance + " wei");
      });
    }
    message = "The deployment of the contract failed, this is the full error message: '" + err.message + "'";
    c.error(err.message);
    throw err;
  };

  deployContract = function(coin_base, contract, res) {
    var Contract, coinbase, ctr, options;
    c.log("Deploying contract: " + contract.name);
    c.log("coinbase", coin_base);
    coinbase = coin_base;
    Contract = eth.contract(contract.abi);
    ctr = contract.compiled.contracts[contract.class_name];
    options = {
      data: "0x" + ctr.bytecode,
      from: coinbase,
      gas: 1e6
    };
    return Contract["new"](options, function(err, contract_instance) {
      var callback, instance;
      instance = contract_instance;
      c.log(contract.class_name + ".new called");
      if (err) {
        return renderDeployError(res, err);
      } else {
        if (instance.address) {
          c.log("  deployed!");
          c.log("  address: " + instance.address + "\n");
          contract.address = instance.address;
          contract.deployed = true;
          saveContractAddress(contract.name, instance.address);
          callback = res;
          return callback(contract);
        }
      }
    });
  };

  module.exports = {
    deployContract: deployContract
  };

}).call(this);
