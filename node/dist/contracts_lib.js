// Generated by CoffeeScript 1.10.0
(function() {
  var _, _string, c, capitalize, classify, config_path, contracts_conf_path, contracts_path, deasync, errCtrClassMismatch, fs, glob, log, path;

  fs = require('fs');

  glob = require("glob");

  path = require('path');

  _ = require('underscore');

  _string = require('underscore.string');

  deasync = require('deasync');

  classify = _string.classify;

  capitalize = _string.capitalize;

  c = console;

  contracts_path = (process.cwd()) + "/contracts";

  config_path = "../config";

  contracts_conf_path = config_path + "/contracts.json";

  log = function(name, contents) {
    c.log("\n" + name + ":");
    c.log(contents);
    return c.log('');
  };

  errCtrClassMismatch = function(contract_class) {
    return "Contract class has to have the same name of the file (found class '" + contract_class + "' defined with a different name from the '.sol' contract file name)";
  };

  module.exports = function(web3) {
    var compileSolidityDeasynced, deleteAddressFromConf, eth, getInstance, parseContract, readConfigs, readContracts;
    eth = web3.eth;
    compileSolidityDeasynced = function(source, name) {
      var result;
      result = null;
      eth.compile.solidity(source, function(err, compiled) {
        if (err) {
          c.error("Error compiling solidity:");
          c.error(err);
          throw "ContractCompilationError - Aborting, check the source code of contract: " + name;
        }
        return result = compiled;
      });
      while (result === null) {
        deasync.runLoopOnce();
      }
      return result;
    };
    getInstance = function(contract) {
      var Contract;
      Contract = eth.contract(contract.abi);
      return Contract.at(contract.address);
    };
    parseContract = function(contract) {
      var abi, abi_methods, compiled, contr, contract_class, getters, methods, setters;
      contract_class = capitalize(classify(contract.name, true));
      compiled = compileSolidityDeasynced(contract.source, contract_class);
      contr = compiled[contract_class];
      if (!contr) {
        throw errCtrClassMismatch(contract_class);
      }
      abi = contr.info.abiDefinition;
      abi = _(abi);
      methods = [];
      getters = [];
      setters = [];
      abi_methods = abi.select(function(token) {
        return token.type === "function";
      });
      abi_methods.map(function(abi_method) {
        var inputTypes, isSetter, method, methodId, type;
        isSetter = abi_method.inputs.length > 0 && !abi_method.constant;
        type = isSetter ? "setter" : "getter";
        inputTypes = _(abi_method.inputs).map(function(inp) {
          return inp.type;
        });
        methodId = web3.sha3(abi_method.name + "(" + (inputTypes.join(',')) + ")").slice(0, 8);
        method = {
          name: abi_method.name,
          kind: type,
          inputs: abi_method.inputs,
          outputs: abi_method.outputs,
          methodId: methodId
        };
        methods.push(method);
        if (method.kind === "getter") {
          return getters.push(method);
        } else {
          return setters.push(method);
        }
      });
      contract = _(contract).extend({
        class_name: contract_class,
        abi: abi.value(),
        compiled: compiled,
        methods: methods,
        getters: getters,
        setters: setters
      });
      contract.instance = getInstance(contract);
      return contract;
    };
    readConfigs = function() {
      var contracts_config;
      contracts_config = fs.readFileSync(contracts_conf_path);
      return JSON.parse(contracts_config);
    };
    deleteAddressFromConf = function(contract_name, callback) {
      var conf;
      conf = readConfigs();
      delete conf[contract_name];
      conf = JSON.stringify(conf, null, 2);
      fs.writeFileSync(contracts_conf_path, conf);
      return callback();
    };
    readContracts = function() {
      var config, contract_files, contracts;
      contracts = [];
      contract_files = glob.sync(contracts_path + "/*.sol");
      config = readConfigs();
      log("contracts.json", config);
      contract_files = _(contract_files).map(function(contract_path) {
        var address, contract, deployed, name, source;
        name = path.basename(contract_path, ".sol");
        source = fs.readFileSync(contract_path);
        address = config[name];
        deployed = address != null;
        contract = {
          name: name,
          path: contract_path,
          source: source.toString(),
          deployed: deployed,
          address: address
        };
        return contracts.push(parseContract(contract));
      });
      return contracts;
    };
    return {
      readContracts: readContracts,
      deleteAddressFromConf: deleteAddressFromConf
    };
  };

}).call(this);
